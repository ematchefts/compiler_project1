package compilerproject2;

import java.io.*;

/**
 *
 * @author Michael
 */
public class CMinusScanner implements Scanner {

    private FileReader inFile;
    private Token nextToken;

    public CMinusScanner(FileReader file) throws IOException {
        inFile = file;
        nextToken = scanToken();
    }

    public Token getNextToken() {
        Token returnToken = nextToken;
        if (nextToken.getTokenType() != Token.TokenType.EOF) {
            try {
                nextToken = scanToken();
            } catch (IOException e) {
            }
        }
        return returnToken;
    }

    public Token viewNextToken() {
        return nextToken;
    }

    public boolean isALetter(int a) {
        return (a >= 'A' && a <= 'Z' || a >= 'a' && a <= 'z');
    }

    // -2 is an unused value. We will know if a used character from
    // the previous iteration is important if this value changes.
    private int buffer = -2;
    private boolean again = true;

    private Token scanToken() throws IOException {
        again = true;
        int currentLetter;
        if (buffer == -2) {
            currentLetter = inFile.read();
        } else {
            // On a previous iteration, an important character was consumed,
            // so it was stored in buffer.
            currentLetter = buffer;
            // Reset buffer.
            buffer = -2;
        }
        int nextLetter;
        Token returnToken = new Token(Token.TokenType.ERROR);
        while (again) {
            again = false;
            switch (currentLetter) {
                // All cases for unambiguous tokens first.
                case -1:
                    returnToken.setTokenType(Token.TokenType.EOF);
                    break;

                case ';':
                    returnToken.setTokenType(Token.TokenType.SEMICOLON);
                    break;

                case ',':
                    returnToken.setTokenType(Token.TokenType.COMMA);
                    break;

                case '(':
                    returnToken.setTokenType(Token.TokenType.LEFTPAREN);
                    break;

                case ')':
                    returnToken.setTokenType(Token.TokenType.RIGHTPAREN);
                    break;

                case '[':
                    returnToken.setTokenType(Token.TokenType.LEFTSQBRACKET);
                    break;

                case ']':
                    returnToken.setTokenType(Token.TokenType.RIGHTSQBRACKET);
                    break;

                case '{':
                    returnToken.setTokenType(Token.TokenType.LEFTBRACE);
                    break;

                case '}':
                    returnToken.setTokenType(Token.TokenType.RIGHTBRACE);
                    break;

                case '+':
                    returnToken.setTokenType(Token.TokenType.PLUS);
                    break;

                case '*':
                    returnToken.setTokenType(Token.TokenType.STAR);
                    break;

                case '!':
                    nextLetter = inFile.read();
                    if (nextLetter == '=') {
                        returnToken.setTokenType(Token.TokenType.NOTEQUAL);
                    }
                    break;

                case '/':
                    nextLetter = inFile.read();
                    if (nextLetter != '*') {
                        returnToken.setTokenType(Token.TokenType.SLASH);

                        // Because this was discovered to not be a comment, the
                        // character we consumed with nextLetter is important, so
                        // it is stored in buffer.
                        buffer = nextLetter;
                    } else {
                        // Found a comment start.
                        boolean endOfCommentFound = false;
                        nextLetter = inFile.read();
                        // Read until the end of the comment is found.
                        while (!endOfCommentFound) {
                            while (nextLetter != '*') {
                                nextLetter = inFile.read();
                            }
                            nextLetter = inFile.read();
                            if (nextLetter == '/') {
                                endOfCommentFound = true;
                            }
                        }
                        // Ensures an error token is not returned
                        again = true;
                        currentLetter = inFile.read();
                    }
                    break;

                case '<':
                    nextLetter = inFile.read();
                    if (nextLetter != '=') {
                        returnToken.setTokenType(Token.TokenType.LESSTHAN);
                        buffer = nextLetter;
                    } else {
                        returnToken.setTokenType(Token.TokenType.LESSTHANEQUALTO);
                    }
                    break;

                case '>':
                    nextLetter = inFile.read();
                    if (nextLetter != '=') {
                        returnToken.setTokenType(Token.TokenType.GREATERTHAN);
                        buffer = nextLetter;
                    } else {
                        returnToken.setTokenType(Token.TokenType.GREATERTHANEQUALTO);
                    }
                    break;

                case '=':
                    nextLetter = inFile.read();
                    if (nextLetter == '=') {
                        returnToken.setTokenType(Token.TokenType.COMPARE);
                    } else {
                        returnToken.setTokenType(Token.TokenType.ASSIGN);
                        buffer = nextLetter;
                    }
                    break;

                case '-':
                    returnToken.setTokenType(Token.TokenType.MINUS);
                    break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':

                    int number = currentLetter - '0';
                    boolean endOfNumFound = false;
                    while (!endOfNumFound) {
                        nextLetter = inFile.read();
                        if (isALetter(nextLetter)) {
                            // Lexical error, next character was a letter.
                            return returnToken;
                        } else {
                            if (nextLetter < '0' || nextLetter > '9') {
                                // Non-number found
                                endOfNumFound = true;
                                buffer = nextLetter;
                            } else {
                                // Update number
                                number = number * 10 + (nextLetter - '0');

                            }
                        }
                    }
                    returnToken.setTokenType(Token.TokenType.NUM);
                    returnToken.setTokenData(number);
                    break;
                case ' ':
                case '\t':
                case '\n':
                case '\r':
                    // Handles all whitespace cases
                    again = true;
                    currentLetter = inFile.read();
                    break;

                default:
                    // Handles reserved words, identifiers, or errors
                    String word = "";
                    boolean endOfWordFound = false;
                    if (isALetter(currentLetter)) {
                        word += (char) currentLetter;
                        nextLetter = inFile.read();
                        while (!endOfWordFound) {
                            if (isALetter(nextLetter)) {
                                word += (char) nextLetter;
                                nextLetter = inFile.read();
                            } else {
                                if (nextLetter >= '0' && nextLetter <= '9') {
                                    // Lexical error, next character was a number.
                                    return returnToken;
                                }
                                buffer = nextLetter;
                                endOfWordFound = true;
                            }
                        }
                        switch (word) {
                            case "else":
                                returnToken.setTokenType(Token.TokenType.ELSE);
                                break;
                            case "if":
                                returnToken.setTokenType(Token.TokenType.IF);
                                break;
                            case "int":
                                returnToken.setTokenType(Token.TokenType.INT);
                                break;
                            case "return":
                                returnToken.setTokenType(Token.TokenType.RETURN);
                                break;
                            case "void":
                                returnToken.setTokenType(Token.TokenType.VOID);
                                break;
                            case "while":
                                returnToken.setTokenType(Token.TokenType.WHILE);
                                break;
                            default:
                                // identifier
                                returnToken.setTokenType(Token.TokenType.IDENT);
                                returnToken.setTokenData(word);
                                break;
                        }

                    }
                    break;
            }
        }
        return returnToken;
    }
}
